<!DOCTYPE html>
<html>
<head>
  <title>Emojityper</title>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Lobster" rel="stylesheet" />
  <link href="styles.css" rel="stylesheet" />
  <script async src="https://cdn.rawgit.com/samthor/rippleJS/v1.0.2/ripple.min.js"></script>
</head>
<body>

<h1>Emojityper</h1>

<main>
  <div id="input">
    <input type="text" id="typer" autocomplete="off" placeholder="Type words, receive emoji &#x1f44d;" autofocus />
    <div class="focus"></div>
  </div>
  <div id="buttons">
    <button id="copy" tabindex="-1" data-copied="Copied!">Copy</button>
  </div>
</main>
<div id="chooser" class="chooser"></div>

<script>
// IE9-11 CustomEvent polyfill
(function() {
  if (typeof window.CustomEvent === 'function') { return false };
  function CustomEvent(name, params) {
    params = params || {bubbles: false, cancelable: false, detail: undefined};
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent(name, params.bubbles, params.cancelable, params.detail);
    return event;
  }
  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
})();

// suggestion handler
(function() {
  // FIXME: sometimes click won't fire
  chooser.addEventListener('click', ev => {
    if (ev.target.localName !== 'button') { return; }
    typer.dispatchEvent(new CustomEvent('emoji', {detail: ev.target.textContent}));
  });

  let focusWord;
  const show = results => {
    chooser.textContent = '';

    results.forEach(result => {
      const options = document.createElement('div');
      options.className = 'options';
      chooser.appendChild(options);

      const heading = document.createElement('h4');
      heading.textContent = result.name;
      options.appendChild(heading);

      result.options.forEach(thing => {
        const option = document.createElement('button');
        option.textContent = thing;
        options.appendChild(option);
      });
    });
  };

  // handler for a word change
  typer.addEventListener('word', ev => {
    focusWord = ev.detail;
    chooser.textContent = '';
    if (!focusWord) { return; }

    // FIXME: queue up real results
    const results = [
      {name: 'banana', options: ['ðŸŒ', 'ðŸ’']},
      {name: 'karate', options: ['ðŸ‘ŠðŸ’¥']},
    ];
    show(results);
  });

  // request an autocomplete, the user has just kept typing
  typer.addEventListener('request', ev => {
    // FIXME: reply with real suggestion
    const choice = 'ðŸš€';
    typer.dispatchEvent(new CustomEvent('emoji', {detail: choice}));
  });

}());

// copy handler
(function(button, input) {
  let timeout;
  const defaultText = button.textContent;

  input.addEventListener('keydown', ev => {
    if (ev.key == 'Enter') {
      button.click();
    }
  });

  button.addEventListener('click', ev => {
    // TODO: not ideal
    input.focus();
    input.selectionStart = 0;
    input.selectionEnd = input.value.length;

    let ok = false;
    try {
      ok = document.execCommand('copy');
    } catch(e) {
      ok = false;
    }
    if (!ok) { return; }

    button.textContent = button.dataset.copied;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(ev => {
      button.textContent = defaultText;
    }, 2000);
  });
}(copy, typer));

// word focus handler
(function(el) {
  const isWordCode = code => {
    // FIXME: turns out matching non-emoji is hard
    return code < 5000 && code != 32;
  };

  const helper = document.createElement('div');
  helper.className = 'overflow-helper';
  el.parentNode.insertBefore(helper, el);

  const underline = document.createElement('div');
  underline.className = 'underline';
  helper.appendChild(underline);

  const sizer = document.createElement('div');
  sizer.className = 'sizer';
  helper.appendChild(sizer);

  // force selection
  const setRange = (from, to) => {
    if (from >= to) {
      underline.hidden = true;
      delete(el.dataset['from']);
      delete(el.dataset['to']);
      delete(el.dataset['word']);
      return false;
    }
    [el.dataset.from, el.dataset.to] = [from, to];
    el.dataset.word = el.value.substr(from, to - from);

    // otherwise, record and draw the line
    const indent = 15;  // FIXME: from CSS, to match `text-indent`
    sizer.textContent = el.value.substr(0, from);
    const left = (from ? sizer.getBoundingClientRect().width : indent);

    sizer.textContent = el.dataset.word;
    const width = sizer.getBoundingClientRect().width - indent;

    underline.hidden = false;
    underline.style.left = left + 'px';
    underline.style.width = width + 'px';
  };

  // update underline transform based on input scrollLeft
  const performScroll = _ => {
    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';
  };

  // state/handler keep track of the current focus word (plus scroll position, if input is big)
  const state = {start: undefined, end: undefined, value: undefined};
  const changeHandler = permitNextChange => {
    performScroll();
    if (el.selectionStart === state.start &&
        el.selectionEnd === state.end &&
        el.value === state.value) {
      return true;  // already at this state
    }
    [state.start, state.end] = [el.selectionStart, el.selectionEnd];
    state.value = el.value;

    // range selection, ignore
    if (state.start !== state.end) { return false; }

    // calculate from/to locally
    let from = state.start;
    let to = state.start;

    // are we at the end (only have spaces until end)?
    const isAtEnd = !el.value.substr(state.end).trim();
    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));

    if (isNotWordAfter) {
      for (; to > 0; --to) {
        if (el.value.charCodeAt(to - 1) !== 32) {
          break;
        }
      }
      if (to < from) {
        from = to;
      }
    }

    // walk backwards while the previous character is a word
    for (; from > 0; --from) {
      if (!isWordCode(el.value.charCodeAt(from - 1))) {
        break;
      }
    }

    // walk forwards while the next char is not a space
    for (; to < el.value.length; ++to) {
      if (!isWordCode(el.value.charCodeAt(to))) {
        break;
      }
    }

    // if it's invalid, but there's not a word after, and we were permitted, ignore
    if (from >= to && isNotWordAfter && permitNextChange) { return; }
    return setRange(from, to);
  };

  // runs change handler and emits the 'word' event as appropriate
  let lastWord = undefined;
  const mergedEventHandler = permitNextChange => {
    if (changeHandler(permitNextChange)) { return; }

    let word = el.dataset.word || null;
    if (word === lastWord) { return; }
    lastWord = word;
    el.dispatchEvent(new CustomEvent('word', {detail: word}))
  };

  // dedup listeners on a rAF
  let frame;
  let permitNextChange;  // FIXME: global-ish scope is ugly
  const dedup = ev => {
    if (!frame) {
      permitNextChange = false;
      frame = window.requestAnimationFrame(_ => {
        frame = null;
        mergedEventHandler(permitNextChange);
      });
    }
  };

  // add a non-deduped keydown handler, to run before others and intercept space
  el.addEventListener('keydown', ev => {
    switch (ev.key) {
    case 'Enter':
      el.dispatchEvent(new CustomEvent('send'));
      break;
    case ' ':
      if (el.dataset.to === undefined || el.selectionStart !== +el.dataset.to) { break; }

      // check that the focus word is all-text, not an emoji
      let valid = true;
      for (let i = 0; i < el.dataset.word.length; ++i) {
        if (!isWordCode(el.dataset.word.charCodeAt(i))) {
          valid = false;
          break;
        }
      }
      if (valid) {
        el.dispatchEvent(new CustomEvent('request'));
      }

      // TODO: do this to prevent actually space being hit (as "Sam Prefers")
      //ev.preventDefault();
      break;
    }
  });

  // lots of listeners for a million different change reasons
  const rest = 'change keydown keypress focus click mousedown';
  rest.split(/\s+/).forEach(event => el.addEventListener(event, dedup));
  el.addEventListener('wheel', ev => window.requestAnimationFrame(performScroll), {passive: true});
  dedup();

  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \o/
  el.addEventListener('emoji', ev => {
    const emoji = ev.detail;
    if (el.dataset.from === undefined || el.dataset.to === undefined) { return; }

    const [from, to] = [+el.dataset.from, +el.dataset.to];
    let start = typer.selectionStart;

    typer.value = typer.value.substr(0, from) + emoji + typer.value.substr(to);

    if (start > to) {
      start = start - (to - from) + emoji.length;
    } else if (start > from) {
      start = from + emoji.length;
    } else {
      // do nothing, was before
    }
    typer.focus();
    typer.dispatchEvent(new CustomEvent('change'));
    typer.selectionStart = start;
    typer.selectionEnd = start;

    permitNextChange = true;
    setRange(from, from + emoji.length);
  });
}(typer));
</script>

</body>
</html>